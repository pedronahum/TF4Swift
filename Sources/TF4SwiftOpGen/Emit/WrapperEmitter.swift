import Foundation

/// Emits simple, compilable wrappers for unary (arity=1) and binary (arity=2) ops
/// into `Sources/TF4SwiftOps/Generated/<Group>/<Group>_Wrappers.swift`.
///
/// NOTE:
///  - Bodies default to `__unimplemented(...)`.
///  - If `wireDynamic` is set, bodies call `OpRunner` (dynamic eager by name).
///  - If `wireRaw` is set (and wireDynamic is false), bodies call `_Raw.<op>`.
enum WrapperEmitter {

  // Emit a broad set by default to accelerate coverage
  static let defaultGroupsToEmit: Set<String> =
    ["math", "nn", "linalg", "array", "image", "random", "io"]

  // Emit these ops even if their plan.group is "other":
  static let alwaysEmitOps: Set<String> = [
    "SoftmaxCrossEntropyWithLogits"
  ]

  // Place these ops under a specific group for wrapper output:
  static let groupOverride: [String:String] = [
    "SoftmaxCrossEntropyWithLogits": "nn"
  ]

  // Two-output ops where both outputs share the same element type:
  static let twoSameTypeOps: Set<String> = [
    "SoftmaxCrossEntropyWithLogits"
  ]

  static func emit(
    plan: [OpPlanRecord],
    groups: Set<String> = defaultGroupsToEmit,
    swiftOutDir: String = "Sources/TF4SwiftOps/Generated",
    verbose: Bool,
    wireRaw: Bool,
    wireDynamic: Bool
  ) throws {

    // Select ops by desired groups (respect the parameter) or allow‑list
    let selected = plan.filter { groups.contains($0.group) || alwaysEmitOps.contains($0.graphOpName) }

    // Bucket by effective group, applying overrides
    let bucketed = Dictionary(grouping: selected, by: { r in
      groupOverride[r.graphOpName] ?? r.group
    })

    for (groupKey, records) in bucketed {
      let groupType = groupTypeName(for: groupKey) // Math / NN / ...
      let dir = (swiftOutDir as NSString).appendingPathComponent(groupType)
      try ensureDir(dir)

      // Split into unary/binary by arity
      let unary = records.filter { $0.arity == 1 }
      let binary = records.filter { $0.arity == 2 }

      var file = [String]()
      file.append("// @generated by tf4swift-opgen — DO NOT EDIT.")
      file.append("// \(Date())")
      file.append("import TF4SwiftCore")
      file.append("")
      file.append("public extension Ops.\(groupType) {")

      // Emit unary wrappers
      if !unary.isEmpty {
        file.append("  // MARK: - Unary element-wise")
        for r in unary.sorted(by: { $0.canonicalName < $1.canonicalName }) {
          file.append(renderUnaryWrapper(group: groupType, r, wireRaw: wireRaw, wireDynamic: wireDynamic))
        }
      }

      // Emit binary wrappers
      if !binary.isEmpty {
        file.append("  // MARK: - Binary element-wise")
        for r in binary.sorted(by: { $0.canonicalName < $1.canonicalName }) {
          file.append(renderBinaryWrapper(group: groupType, r, wireRaw: wireRaw, wireDynamic: wireDynamic))
        }
      }

      file.append("}") // close extension
      file.append("")

      let path = (dir as NSString).appendingPathComponent("\(groupType)_Wrappers.swift")
      try file.joined(separator: "\n").write(to: URL(fileURLWithPath: path), atomically: true, encoding: .utf8)
      if verbose { print("[opgen] Wrote \(path)") }
    }
  }

  // MARK: - Renderers

  private static func renderUnaryWrapper(group: String, _ r: OpPlanRecord, wireRaw: Bool, wireDynamic: Bool) -> String {
    let fn = swiftIdent(r.canonicalName)
    let summary = r.summary ?? "Unary operation."
    let raw = lowerCamel(r.graphOpName)

    // Keep it simple for now; attribute‑aware signatures come later.
    let returnType = twoSameTypeOps.contains(r.graphOpName) && r.numOutputs == 2
      ? "(Tensor<T>, Tensor<T>)" : "Tensor<T>"

    let body: String
    if wireDynamic {
      if twoSameTypeOps.contains(r.graphOpName) && r.numOutputs == 2 {
        body = #"OpRunner.unary2("\#(r.graphOpName)", in: ctx, x)"#
      } else {
        body = #"OpRunner.unary("\#(r.graphOpName)", in: ctx, x)"#
      }
    } else if wireRaw {
      if twoSameTypeOps.contains(r.graphOpName) && r.numOutputs == 2 {
        body = #"__unimplemented("\#(Self.self)::\#(fn) → \#(r.graphOpName) (two outputs not wired for _Raw)")"#
      } else {
        body = #"_Raw.\#(raw)(x)"#
      }
    } else {
      body = #"__unimplemented("\#(Self.self)::\#(fn) → \#(r.graphOpName)")"#
    }

    return """
      /// \(summary)
      /// - Graph op: \(r.graphOpName)
      @inlinable
      func \(fn)<T>(_ x: Tensor<T>) -> \(returnType) {
        \(body)
      }

    """
  }

  private static func renderBinaryWrapper(group: String, _ r: OpPlanRecord, wireRaw: Bool, wireDynamic: Bool) -> String {
    let fn = swiftIdent(r.canonicalName)
    let summary = r.summary ?? "Binary element-wise operation."
    let raw = lowerCamel(r.graphOpName)

    let returnType = twoSameTypeOps.contains(r.graphOpName)
      ? "(Tensor<T>, Tensor<T>)" : "Tensor<T>"

    let body: String
    if wireDynamic {
      body = twoSameTypeOps.contains(r.graphOpName)
        ? #"OpRunner.binary2("\#(r.graphOpName)", in: ctx, x, y)"#
        : #"OpRunner.binary("\#(r.graphOpName)", in: ctx, x, y)"#
    } else if wireRaw {
      body = twoSameTypeOps.contains(r.graphOpName)
        ? #"__unimplemented("\#(Self.self)::\#(fn) → \#(r.graphOpName) (two outputs not wired for _Raw)")"#
        : #"_Raw.\#(raw)(x, y)"#
    } else {
      body = #"__unimplemented("\#(Self.self)::\#(fn) → \#(r.graphOpName)")"#
    }

    return """
      /// \(summary)
      /// - Graph op: \(r.graphOpName)
      @inlinable
      func \(fn)<T>(_ x: Tensor<T>, _ y: Tensor<T>) -> \(returnType) {
        \(body)
      }

    """
  }

  // MARK: - Shared helpers

  private static func ensureDir(_ path: String) throws {
    var isDir: ObjCBool = false
    if !FileManager.default.fileExists(atPath: path, isDirectory: &isDir) {
      try FileManager.default.createDirectory(atPath: path, withIntermediateDirectories: true)
    } else if !isDir.boolValue {
      throw GeneratorError.io("Path exists and is not a directory: \(path)")
    }
  }

  private static func groupTypeName(for group: String) -> String {
    switch group.lowercased() {
    case "math": return "Math"
    case "nn": return "NN"
    case "array": return "Array"
    case "linalg": return "Linalg"
    case "image": return "Image"
    case "random": return "Random"
    case "io": return "IO"
    case "control": return "Control"
    default: return "Other"
    }
  }

  private static func swiftIdent(_ s: String) -> String {
    let ok = s.unicodeScalars.map { ch -> Character in
      let v = ch.value
      if (v >= 48 && v <= 57) || (v >= 65 && v <= 90) || (v >= 97 && v <= 122) || ch == "_" {
        return Character(String(ch))
      } else { return "_" }
    }
    var ident = String(ok)
    if let first = ident.first, first.isNumber { ident = "_" + ident }
    let reserved: Set<String> = [
      "associatedtype","class","deinit","enum","extension","fileprivate","func","import","init",
      "inout","internal","let","open","operator","private","precedencegroup","protocol","public",
      "rethrows","static","struct","subscript","typealias","var",
      "break","case","continue","default","defer","do","else","fallthrough","for","guard","if",
      "in","repeat","return","switch","where","while",
      "as","Any","catch","false","is","nil","super","self","Self","throw","throws","true","try",
      "await","async","actor","nonisolated","distributed","some","any",
      "macro","borrow","borrowing","consume","consuming","yield","_"
    ]
    if reserved.contains(ident) { ident = "`" + ident + "`" }
    return ident
  }

  private static func lowerCamel(_ s: String) -> String {
    guard let first = s.first else { return s }
    return String(first).lowercased() + s.dropFirst()
  }
}
