import Foundation

/// Emits grouped Swift files under `Sources/TF4SwiftOps/Generated/<Group>/Index.swift`.
/// Each `Index.swift` provides:
///   public extension Ops.<Group> { enum Names { ... static let all: [String:String] = ... } }
///
/// We do not generate wrappers yet; Week 2+ will use this registry to emit signatures/VJPs.
enum SwiftEmitter {

  static func emit(plan: [OpPlanRecord],
                   swiftOutDir: String = "Sources/TF4SwiftOps/Generated",
                   verbose: Bool) throws {
    // 1) Group the plan by group string
    let byGroup = Dictionary(grouping: plan, by: { $0.group })

    // 2) Ensure base generated dir
    try ensureDir(swiftOutDir)

    // 3) Emit per-group index files
    for (grp, records) in byGroup {
      let groupName = grpTrunc(grp)                  // e.g. "math"
      let typeName  = groupTypeName(for: groupName)  // e.g. "Math"
      let dir       = (swiftOutDir as NSString).appendingPathComponent(typeName)
      try ensureDir(dir)

      // Build canonical->graph mapping. If multiple ops share the same canonical name,
      // retain the first occurrence (stable; order comes from plan).
      var table: [(canonical: String, graph: String)] = []
      var seen = Set<String>()
      for r in records {
        guard !r.canonicalName.isEmpty, !r.graphOpName.isEmpty else { continue }
        if !seen.contains(r.canonicalName) {
          table.append((r.canonicalName, r.graphOpName))
          seen.insert(r.canonicalName)
        }
      }

      //let filePath = (dir as NSString).appendingPathComponent("Index.swift")
      let fileName = "\(typeName)_Names.swift"
      let filePath = (dir as NSString).appendingPathComponent(fileName)

      
      let contents = renderIndexFile(groupType: typeName, pairs: table)
      try contents.write(to: URL(fileURLWithPath: filePath), atomically: true, encoding: .utf8)
      if verbose { print("[opgen] Wrote \(filePath)") }
    }

    // 4) Ensure Ops.swift exists (do not overwrite—hand written file)
    try ensureOpsRootIfMissing(verbose: verbose)
  }

  // MARK: - Rendering

  private static func renderIndexFile(groupType: String,
                                      pairs: [(canonical: String, graph: String)]) -> String {
    var lines: [String] = []
    lines.append("// @generated by tf4swift-opgen — DO NOT EDIT.")
    lines.append("// \(Date())")
    lines.append("import TF4SwiftCore")
    lines.append("")
    lines.append("public extension Ops.\(groupType) {")
    lines.append("  /// Canonical operation names mapped to TensorFlow graph op names available in this build.")
    lines.append("  enum Names {")
    if pairs.isEmpty {
      lines.append("    /// No known operations in this group (for this runtime/API set).")
    } else {
      // Emit one static let per canonical name
      for (canon, graph) in pairs.sorted(by: { $0.canonical < $1.canonical }) {
        lines.append("    /// TF op: \(graph)")
        lines.append("    public static let \(swiftIdent(canon)) = \"\(graph)\"")
      }
      
      // Canonical → Graph op name lookup
      lines.append("    public static let canonicalToGraph: [String:String] = [")
      for (canon, graph) in pairs.sorted(by: { $0.canonical < $1.canonical }) {
        lines.append("      \"\(canon)\": \"\(graph)\",")
      }
      lines.append("    ]")
    }
    lines.append("  }")
    lines.append("}")
    lines.append("")
    return lines.joined(separator: "\n")
  }

  // MARK: - Helpers

  private static func ensureOpsRootIfMissing(verbose: Bool) throws {
    let opsPath = "Sources/TF4SwiftOps/Ops.swift"
    if !FileManager.default.fileExists(atPath: opsPath) {
      let content = """
      import TF4SwiftCore

      public struct Ops {
        public let ctx: EagerContext
        public init(_ ctx: EagerContext) { self.ctx = ctx }

        public var math: Math { .init(ctx) }
        public var nn: NN { .init(ctx) }
        public var array: Array { .init(ctx) }
        public var linalg: Linalg { .init(ctx) }
        public var image: Image { .init(ctx) }
        public var random: Random { .init(ctx) }
        public var io: IO { .init(ctx) }
        public var control: Control { .init(ctx) }
        public var other: Other { .init(ctx) }
      }

      public extension Ops {
        struct Math   { let ctx: EagerContext; public init(_ ctx: EagerContext) { self.ctx = ctx } }
        struct NN     { let ctx: EagerContext; public init(_ ctx: EagerContext) { self.ctx = ctx } }
        struct Array  { let ctx: EagerContext; public init(_ ctx: EagerContext) { self.ctx = ctx } }
        struct Linalg { let ctx: EagerContext; public init(_ ctx: EagerContext) { self.ctx = ctx } }
        struct Image  { let ctx: EagerContext; public init(_ ctx: EagerContext) { self.ctx = ctx } }
        struct Random { let ctx: EagerContext; public init(_ ctx: EagerContext) { self.ctx = ctx } }
        struct IO     { let ctx: EagerContext; public init(_ ctx: EagerContext) { self.ctx = ctx } }
        struct Control{ let ctx: EagerContext; public init(_ ctx: EagerContext) { self.ctx = ctx } }
        struct Other  { let ctx: EagerContext; public init(_ ctx: EagerContext) { self.ctx = ctx } }
      }
      """
      try content.write(to: URL(fileURLWithPath: opsPath), atomically: true, encoding: .utf8)
      if verbose { print("[opgen] Created \(opsPath)") }
    }
  }

  private static func ensureDir(_ path: String) throws {
    var isDir: ObjCBool = false
    if !FileManager.default.fileExists(atPath: path, isDirectory: &isDir) {
      try FileManager.default.createDirectory(atPath: path, withIntermediateDirectories: true)
    } else if !isDir.boolValue {
      throw GeneratorError.io("Path exists but is not a directory: \(path)")
    }
  }

  private static func grpTrunc(_ s: String) -> String { s.trimmingCharacters(in: .whitespacesAndNewlines).lowercased() }

  private static func groupTypeName(for group: String) -> String {
    switch group {
    case "math": return "Math"
    case "nn": return "NN"
    case "array": return "Array"
    case "linalg": return "Linalg"
    case "image": return "Image"
    case "random": return "Random"
    case "io": return "IO"
    case "control": return "Control"
    default: return "Other"
    }
  }

    private static func swiftIdent(_ s: String) -> String {
    // allow [A-Za-z0-9_], convert others to underscore
    let ok = s.unicodeScalars.map { ch -> Character in
      let v = ch.value
      if (v >= 48 && v <= 57) || (v >= 65 && v <= 90) || (v >= 97 && v <= 122) || ch == "_" {
        return Character(String(ch))
      } else {
        return "_"
      }
    }
    var ident = String(ok)
    // avoid leading digits
    if let first = ident.first, first.isNumber { ident = "_" + ident }

    // Swift reserved words to escape with backticks
    // (covers declarations, statements, and common contextuals)
    let reserved: Set<String> = [
      "associatedtype","class","deinit","enum","extension","fileprivate","func","import","init",
      "inout","internal","let","open","operator","private","precedencegroup","protocol","public",
      "rethrows","static","struct","subscript","typealias","var",
      "break","case","continue","default","defer","do","else","fallthrough","for","guard","if",
      "in","repeat","return","switch","where","while",
      "as","Any","catch","false","is","nil","super","self","Self","throw","throws","true","try",
      // Swift 5.5+/6 concurrency & actors keywords
      "await","async","actor","nonisolated","distributed","some","any",
      // misc.
      "macro","borrow","borrowing","consume","consuming","yield","_"
    ]

    if reserved.contains(ident) { ident = "`" + ident + "`" }
    return ident
  }

}
