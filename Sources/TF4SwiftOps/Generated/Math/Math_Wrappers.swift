// @generated by tf4swift-opgen â€” DO NOT EDIT.
// 2025-09-08 15:29:30 +0000
import TF4SwiftCore

public extension Ops.Math {
  // MARK: - Unary element-wise
  /// Unary operation.
  /// - Graph op: Acosh
  @inlinable
  func acosh<T>(_ x: Tensor<T>) -> Tensor<T> {
    OpRunner.unary("Acosh", in: ctx, x)
  }

  /// Unary operation.
  /// - Graph op: Asin
  @inlinable
  func asin<T>(_ x: Tensor<T>) -> Tensor<T> {
    OpRunner.unary("Asin", in: ctx, x)
  }

  /// Unary operation.
  /// - Graph op: Asinh
  @inlinable
  func asinh<T>(_ x: Tensor<T>) -> Tensor<T> {
    OpRunner.unary("Asinh", in: ctx, x)
  }

  /// Unary operation.
  /// - Graph op: Atan
  @inlinable
  func atan<T>(_ x: Tensor<T>) -> Tensor<T> {
    OpRunner.unary("Atan", in: ctx, x)
  }

  /// Unary operation.
  /// - Graph op: Atanh
  @inlinable
  func atanh<T>(_ x: Tensor<T>) -> Tensor<T> {
    OpRunner.unary("Atanh", in: ctx, x)
  }

  /// Unary operation.
  /// - Graph op: Cos
  @inlinable
  func cos<T>(_ x: Tensor<T>) -> Tensor<T> {
    OpRunner.unary("Cos", in: ctx, x)
  }

  /// Unary operation.
  /// - Graph op: Cosh
  @inlinable
  func cosh<T>(_ x: Tensor<T>) -> Tensor<T> {
    OpRunner.unary("Cosh", in: ctx, x)
  }

  /// Unary operation.
  /// - Graph op: Digamma
  @inlinable
  func digamma<T>(_ x: Tensor<T>) -> Tensor<T> {
    OpRunner.unary("Digamma", in: ctx, x)
  }

  /// Unary operation.
  /// - Graph op: Erf
  @inlinable
  func erf<T>(_ x: Tensor<T>) -> Tensor<T> {
    OpRunner.unary("Erf", in: ctx, x)
  }

  /// Unary operation.
  /// - Graph op: Erfc
  @inlinable
  func erfc<T>(_ x: Tensor<T>) -> Tensor<T> {
    OpRunner.unary("Erfc", in: ctx, x)
  }

  /// Unary operation.
  /// - Graph op: Expm1
  @inlinable
  func expm1<T>(_ x: Tensor<T>) -> Tensor<T> {
    OpRunner.unary("Expm1", in: ctx, x)
  }

  /// Unary operation.
  /// - Graph op: InvertPermutation
  @inlinable
  func invert_permutation<T>(_ x: Tensor<T>) -> Tensor<T> {
    OpRunner.unary("InvertPermutation", in: ctx, x)
  }

  /// Unary operation.
  /// - Graph op: IsFinite
  @inlinable
  func is_finite<T>(_ x: Tensor<T>) -> Tensor<T> {
    OpRunner.unary("IsFinite", in: ctx, x)
  }

  /// Unary operation.
  /// - Graph op: IsInf
  @inlinable
  func is_inf<T>(_ x: Tensor<T>) -> Tensor<T> {
    OpRunner.unary("IsInf", in: ctx, x)
  }

  /// Unary operation.
  /// - Graph op: IsNan
  @inlinable
  func is_nan<T>(_ x: Tensor<T>) -> Tensor<T> {
    OpRunner.unary("IsNan", in: ctx, x)
  }

  /// Unary operation.
  /// - Graph op: Lgamma
  @inlinable
  func lgamma<T>(_ x: Tensor<T>) -> Tensor<T> {
    OpRunner.unary("Lgamma", in: ctx, x)
  }

  /// Unary operation.
  /// - Graph op: Log
  @inlinable
  func log<T>(_ x: Tensor<T>) -> Tensor<T> {
    OpRunner.unary("Log", in: ctx, x)
  }

  /// Unary operation.
  /// - Graph op: Log1p
  @inlinable
  func log1p<T>(_ x: Tensor<T>) -> Tensor<T> {
    OpRunner.unary("Log1p", in: ctx, x)
  }

  /// Unary operation.
  /// - Graph op: LogicalNot
  @inlinable
  func logical_not<T>(_ x: Tensor<T>) -> Tensor<T> {
    OpRunner.unary("LogicalNot", in: ctx, x)
  }

  /// Unary operation.
  /// - Graph op: Neg
  @inlinable
  func negative<T>(_ x: Tensor<T>) -> Tensor<T> {
    OpRunner.unary("Neg", in: ctx, x)
  }

  /// Unary operation.
  /// - Graph op: Reciprocal
  @inlinable
  func reciprocal<T>(_ x: Tensor<T>) -> Tensor<T> {
    OpRunner.unary("Reciprocal", in: ctx, x)
  }

  /// Unary operation.
  /// - Graph op: Rint
  @inlinable
  func rint<T>(_ x: Tensor<T>) -> Tensor<T> {
    OpRunner.unary("Rint", in: ctx, x)
  }

  /// Unary operation.
  /// - Graph op: Sin
  @inlinable
  func sin<T>(_ x: Tensor<T>) -> Tensor<T> {
    OpRunner.unary("Sin", in: ctx, x)
  }

  /// Unary operation.
  /// - Graph op: Sinh
  @inlinable
  func sinh<T>(_ x: Tensor<T>) -> Tensor<T> {
    OpRunner.unary("Sinh", in: ctx, x)
  }

  /// Unary operation.
  /// - Graph op: Square
  @inlinable
  func square<T>(_ x: Tensor<T>) -> Tensor<T> {
    OpRunner.unary("Square", in: ctx, x)
  }

  /// Unary operation.
  /// - Graph op: Tan
  @inlinable
  func tan<T>(_ x: Tensor<T>) -> Tensor<T> {
    OpRunner.unary("Tan", in: ctx, x)
  }

  /// Unary operation.
  /// - Graph op: Tanh
  @inlinable
  func tanh<T>(_ x: Tensor<T>) -> Tensor<T> {
    OpRunner.unary("Tanh", in: ctx, x)
  }

  // MARK: - Binary element-wise
  /// Binary element-wise operation.
  /// - Graph op: Atan2
  @inlinable
  func atan2<T>(_ x: Tensor<T>, _ y: Tensor<T>) -> Tensor<T> {
    OpRunner.binary("Atan2", in: ctx, x, y)
  }

  /// Binary element-wise operation.
  /// - Graph op: FloorMod
  @inlinable
  func floormod<T>(_ x: Tensor<T>, _ y: Tensor<T>) -> Tensor<T> {
    OpRunner.binary("FloorMod", in: ctx, x, y)
  }

  /// Binary element-wise operation.
  /// - Graph op: Greater
  @inlinable
  func greater<T>(_ x: Tensor<T>, _ y: Tensor<T>) -> Tensor<T> {
    OpRunner.binary("Greater", in: ctx, x, y)
  }

  /// Binary element-wise operation.
  /// - Graph op: GreaterEqual
  @inlinable
  func greater_equal<T>(_ x: Tensor<T>, _ y: Tensor<T>) -> Tensor<T> {
    OpRunner.binary("GreaterEqual", in: ctx, x, y)
  }

  /// Binary element-wise operation.
  /// - Graph op: Igamma
  @inlinable
  func igamma<T>(_ x: Tensor<T>, _ y: Tensor<T>) -> Tensor<T> {
    OpRunner.binary("Igamma", in: ctx, x, y)
  }

  /// Binary element-wise operation.
  /// - Graph op: Igammac
  @inlinable
  func igammac<T>(_ x: Tensor<T>, _ y: Tensor<T>) -> Tensor<T> {
    OpRunner.binary("Igammac", in: ctx, x, y)
  }

  /// Binary element-wise operation.
  /// - Graph op: Less
  @inlinable
  func less<T>(_ x: Tensor<T>, _ y: Tensor<T>) -> Tensor<T> {
    OpRunner.binary("Less", in: ctx, x, y)
  }

  /// Binary element-wise operation.
  /// - Graph op: LessEqual
  @inlinable
  func less_equal<T>(_ x: Tensor<T>, _ y: Tensor<T>) -> Tensor<T> {
    OpRunner.binary("LessEqual", in: ctx, x, y)
  }

  /// Binary element-wise operation.
  /// - Graph op: LogicalAnd
  @inlinable
  func logical_and<T>(_ x: Tensor<T>, _ y: Tensor<T>) -> Tensor<T> {
    OpRunner.binary("LogicalAnd", in: ctx, x, y)
  }

  /// Binary element-wise operation.
  /// - Graph op: LogicalOr
  @inlinable
  func logical_or<T>(_ x: Tensor<T>, _ y: Tensor<T>) -> Tensor<T> {
    OpRunner.binary("LogicalOr", in: ctx, x, y)
  }

  /// Binary element-wise operation.
  /// - Graph op: Maximum
  @inlinable
  func maximum<T>(_ x: Tensor<T>, _ y: Tensor<T>) -> Tensor<T> {
    OpRunner.binary("Maximum", in: ctx, x, y)
  }

  /// Binary element-wise operation.
  /// - Graph op: Minimum
  @inlinable
  func minimum<T>(_ x: Tensor<T>, _ y: Tensor<T>) -> Tensor<T> {
    OpRunner.binary("Minimum", in: ctx, x, y)
  }

  /// Binary element-wise operation.
  /// - Graph op: NextAfter
  @inlinable
  func nextafter<T>(_ x: Tensor<T>, _ y: Tensor<T>) -> Tensor<T> {
    OpRunner.binary("NextAfter", in: ctx, x, y)
  }

  /// Binary element-wise operation.
  /// - Graph op: Polygamma
  @inlinable
  func polygamma<T>(_ x: Tensor<T>, _ y: Tensor<T>) -> Tensor<T> {
    OpRunner.binary("Polygamma", in: ctx, x, y)
  }

  /// Binary element-wise operation.
  /// - Graph op: SegmentMax
  @inlinable
  func segment_max<T>(_ x: Tensor<T>, _ y: Tensor<T>) -> Tensor<T> {
    OpRunner.binary("SegmentMax", in: ctx, x, y)
  }

  /// Binary element-wise operation.
  /// - Graph op: SegmentMean
  @inlinable
  func segment_mean<T>(_ x: Tensor<T>, _ y: Tensor<T>) -> Tensor<T> {
    OpRunner.binary("SegmentMean", in: ctx, x, y)
  }

  /// Binary element-wise operation.
  /// - Graph op: SegmentMin
  @inlinable
  func segment_min<T>(_ x: Tensor<T>, _ y: Tensor<T>) -> Tensor<T> {
    OpRunner.binary("SegmentMin", in: ctx, x, y)
  }

  /// Binary element-wise operation.
  /// - Graph op: SegmentProd
  @inlinable
  func segment_prod<T>(_ x: Tensor<T>, _ y: Tensor<T>) -> Tensor<T> {
    OpRunner.binary("SegmentProd", in: ctx, x, y)
  }

  /// Binary element-wise operation.
  /// - Graph op: SegmentSum
  @inlinable
  func segment_sum<T>(_ x: Tensor<T>, _ y: Tensor<T>) -> Tensor<T> {
    OpRunner.binary("SegmentSum", in: ctx, x, y)
  }

  /// Binary element-wise operation.
  /// - Graph op: SquaredDifference
  @inlinable
  func squared_difference<T>(_ x: Tensor<T>, _ y: Tensor<T>) -> Tensor<T> {
    OpRunner.binary("SquaredDifference", in: ctx, x, y)
  }

  /// Binary element-wise operation.
  /// - Graph op: Xlogy
  @inlinable
  func xlogy<T>(_ x: Tensor<T>, _ y: Tensor<T>) -> Tensor<T> {
    OpRunner.binary("Xlogy", in: ctx, x, y)
  }

  /// Binary element-wise operation.
  /// - Graph op: Zeta
  @inlinable
  func zeta<T>(_ x: Tensor<T>, _ y: Tensor<T>) -> Tensor<T> {
    OpRunner.binary("Zeta", in: ctx, x, y)
  }

}
